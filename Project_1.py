# -*- coding: utf-8 -*-
"""Design_Credit_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A_l-2bkl97G2BefmGvhmSElUYCsLOH1-

**Fault diagnosis of a rotor-bearing system using machine learning techniques**
"""

from google.colab import drive
drive.mount('/content/drive')

"""**Abstract:**

In the fields of science and engineering, classification of faults in rotary machines using machine learning is gaining popularity. A common mistake in rotating machinery is misalignment. In order to identify misalignments in rotary machines under various circumstances, this project suggests a method based on machine learning techniques. To find misalignment faults, a personalized diagnostic fault method is suggested.

![WhatsApp Image 2022-11-14 at 13.26.48.jpg](data:image/jpeg;base64,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)

# Visualise

## Import Libraries
"""

pip install librosa

!pip install python_speech_features

import keras

import librosa
from glob import glob
from keras.utils import to_categorical
from scipy.io import wavfile
from keras.layers import Conv2D, MaxPool2D, Flatten, LSTM
from keras.layers import Dropout, Dense, TimeDistributed
from keras.models import Sequential
from keras.utils import to_categorical
from sklearn.utils.class_weight import compute_class_weight
import os
from tqdm import tqdm
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.io import wavfile
from python_speech_features import mfcc, logfbank 
import librosa
import soundfile as sf
import numpy as np
import wave
import struct

"""## Import Dataset and Visualise
The dataset was divided into three parts, Pressure, Displacement and Force. The columns were named NON_FAULTY, RIGHT_AND_LEFT_BEARING, Right_Bearing and UNBALANCE_FORCE in all the datasets.

> These three datasets were imported separately and On each of their columns Fast Fourier Transform were applied and Visualise

### Observation


> It was observed that they were showing good variation even for small time intervals. Therefore, it is not possible to simply make a Mel Spectrogram and apply CNN since each node would get split several parts due to FFT, and this would lead to data loss and hence, a poor accuracy. This is why the columns were first coverted into sound signals.

### Import Pressure Dataset
"""

# Read the CSV file
df_pressure = pd.read_csv('/content/drive/MyDrive/Design Credit/DataSet/csv/Pressure.csv')

# Loop through the sheets and process the data
for sheet_name, sheet_data in df_pressure.items():
    # Do some processing on the sheet data
    print(f"Processing sheet {sheet_name}")
    # Use Librosa to analyze the audio data in the sheet

col_names_pressure = df_pressure.columns

# Loop through each column and create a plot
for col_name in col_names_pressure:
    # Create a new figure for each plot
    plt.figure()
    # Plot the data
    plt.plot(df_pressure[col_name])
    # Set the title and axis labels
    plt.title(col_name)
    plt.xlabel('Time (samples)')
    plt.ylabel('Value')
    # Show the plot
    plt.show()

"""### Import Dispalcement Dataset"""

# Read the CSV file
df_displacement = pd.read_csv('/content/drive/MyDrive/Design Credit/DataSet/csv/Displacement.csv')

# Loop through the sheets and process the data
for sheet_name, sheet_data in df_displacement.items():
    # Do some processing on the sheet data
    print(f"Processing sheet {sheet_name}")
    # Use Librosa to analyze the audio data in the sheet

col_names_displacement = df_displacement.columns

# Loop through each column and create a plot
for col_name in col_names_displacement:
    # Create a new figure for each plot
    plt.figure()
    # Plot the data
    plt.plot(df_displacement[col_name])
    # Set the title and axis labels
    plt.title(col_name)
    plt.xlabel('Time (samples)')
    plt.ylabel('Value')
    # Show the plot
    plt.show()

"""### Import Force Dataset"""

# Read the CSV file
df_Force = pd.read_csv('/content/drive/MyDrive/Design Credit/DataSet/csv/Displacement.csv')

# Loop through the sheets and process the data
for sheet_name, sheet_data in df_Force.items():
    # Do some processing on the sheet data
    print(f"Processing sheet {sheet_name}")
    # Use Librosa to analyze the audio data in the sheet

col_names_Force = df_Force.columns

# Loop through each column and create a plot
for col_name in col_names_Force:
    # Create a new figure for each plot
    plt.figure()
    # Plot the data
    plt.plot(df_Force[col_name])
    # Set the title and axis labels
    plt.title(col_name)
    plt.xlabel('Time (samples)')
    plt.ylabel('Value')
    # Show the plot
    plt.show()

"""## Saving Dataset in form of sound

Each column of the previously imported three datasets is now converted into a sound signal.

> The sample rate for constructing the sound signals from columns was set to 1/7.8e-5 because the sensor was collecting data with a time period of 7.8e-5 s for a time interval of 30s.
"""

for col_name in col_names_pressure:
    # Convert the column to a NumPy array
    audio_data = df_pressure[col_name].to_numpy()
    # Replace NaN values with zeros
    audio_data = np.where(np.isnan(audio_data), 0, audio_data)
    # Normalize the audio data to the range [-1, 1]
    audio_data /= max(abs(audio_data))
    # Set the sample rate (in Hz)
    sample_rate = int(1/7.8e-5)
    # Set the number of channels
    nchannels = 1 if len(audio_data.shape) == 1 else audio_data.shape[1]
    # Open a new WAV file for writing
    with wave.open(f'{col_name}.wav', 'w') as wav_file:
        # Set the parameters of the WAV file
        sampwidth = 2
        comptype = "NONE"
        compname = "not compressed"
        # Set the sample rate, number of channels, and number of frames
        wav_file.setparams((nchannels, sampwidth, sample_rate, len(audio_data), comptype, compname))
        # Write each audio sample to the file
        for sample in audio_data.flatten():
            sample = int(sample * 32767) # Convert to 16-bit integer
            wav_file.writeframes(struct.pack('h', sample))

for col_name in col_names_displacement:
    # Convert the column to a NumPy array
    audio_data = df_displacement[col_name].to_numpy()
    # Replace NaN values with zeros
    audio_data = np.where(np.isnan(audio_data), 0, audio_data)
    # Normalize the audio data to the range [-1, 1]
    audio_data /= max(abs(audio_data))
    # Set the sample rate (in Hz)
    sample_rate = int(1/7.8e-5)
    # Set the number of channels
    nchannels = 1 if len(audio_data.shape) == 1 else audio_data.shape[1]
    # Open a new WAV file for writing
    with wave.open(f'{col_name}.wav', 'w') as wav_file:
        # Set the parameters of the WAV file
        sampwidth = 2
        comptype = "NONE"
        compname = "not compressed"
        # Set the sample rate, number of channels, and number of frames
        wav_file.setparams((nchannels, sampwidth, sample_rate, len(audio_data), comptype, compname))
        # Write each audio sample to the file
        for sample in audio_data.flatten():
            sample = int(sample * 32767) # Convert to 16-bit integer
            wav_file.writeframes(struct.pack('h', sample))

for col_name in col_names_Force:
    # Convert the column to a NumPy array
    audio_data = df_Force[col_name].to_numpy()
    # Replace NaN values with zeros
    audio_data = np.where(np.isnan(audio_data), 0, audio_data)
    # Normalize the audio data to the range [-1, 1]
    audio_data /= max(abs(audio_data))
    # Set the sample rate (in Hz)
    sample_rate = int(1/7.8e-5)
    # Set the number of channels
    nchannels = 1 if len(audio_data.shape) == 1 else audio_data.shape[1]
    # Open a new WAV file for writing
    with wave.open(f'{col_name}.wav', 'w') as wav_file:
        # Set the parameters of the WAV file
        sampwidth = 2
        comptype = "NONE"
        compname = "not compressed"
        # Set the sample rate, number of channels, and number of frames
        wav_file.setparams((nchannels, sampwidth, sample_rate, len(audio_data), comptype, compname))
        # Write each audio sample to the file
        for sample in audio_data.flatten():
            sample = int(sample * 32767) # Convert to 16-bit integer
            wav_file.writeframes(struct.pack('h', sample))

"""## Preprocess Sound

### Functions
Functions were made to plot signals, mel spectrogram and an envelope function which removes dead space from the signal.
"""

def plot_signals(signals):
    fig, axs = plt.subplots(nrows=len(signals), ncols=1, figsize=(20, len(signals)*3))
    fig.subplots_adjust(hspace=0.5)
    for i, (key, signal) in enumerate(signals.items()):
        axs[i].set_title(key)
        axs[i].plot(signal)
        axs[i].set_xlim([0, len(signal)])
        axs[i].set_xlabel('Sample')
        axs[i].set_ylabel('Amplitude')
        axs[i].grid(True)
    plt.show()
def plot_fft(fft):
    for i, (label, (Y, freq)) in enumerate(fft.items()):
        plt.figure(figsize=(10, 6))
        plt.plot(freq, Y)
        plt.title(label)
        plt.xlim([0,2000])
        plt.ylim([0,0.0150])
        plt.xlabel('Frequency (Hz)')
        plt.ylabel('Magnitude')

def calc_fft(y, rate):
    n = len(y)
    freq = np.fft.rfftfreq(n, d=1/rate)
    Y = abs(np.fft.rfft(y)/n)
    return (Y, freq)
def envelope (y, rate, threshold):
    mask = []
    y = pd.Series (y).apply(np.abs)
    y_mean = y.rolling(window=int(rate/10), min_periods=1, center=True).mean()

    for mean in y_mean:
        if mean == threshold: 
          mask.append(True)
        else:
          mask.append(False)
    return mask
def plot_fbank(fbank):
    fig, axes = plt.subplots(nrows=len(fbank), ncols=1, sharex=False, sharey=True, figsize=(5,130))
    for i, (key, val) in enumerate(fbank.items()):
        axes[i].set_title(key)
        axes[i].imshow(val, cmap='hot', interpolation='nearest', aspect='auto')
        axes[i].get_xaxis().set_visible(False)
        axes[i].get_yaxis().set_visible(False)

def plot_mfccs(mfccs):
    fig, axes = plt.subplots(nrows=len(mfccs), ncols=1, sharex=False, sharey=True, figsize=(5,130))
    for i, (key, val) in enumerate(mfccs.items()):
        axes[i].set_title(key)
        axes[i].imshow(val, cmap='hot', interpolation='nearest', aspect='auto')
        axes[i].get_xaxis().set_visible(False)
        axes[i].get_yaxis().set_visible(False)

"""### Distribution of data
The distribution of data with respect to Class 1, Class 2, Class 3 and Class 4 was visualized.

Class 1 is Non-Faulty

Class 2 is Right and Left Bearing Fault

Class 3 is Right Bearing

Class 4 is Unbalance Force
"""

# Path to the main directory containing class folders
main_dir = '/content/drive/MyDrive/Design Credit/train_audio'

# Get a list of subdirectories (i.e. class folders) in the main directory
subdirs = [x[0] for x in os.walk(main_dir)][1:]

# Count the number of .wav files in each subdirectory
counts = []
for subdir in subdirs:
    wav_count = len([file for file in os.listdir(subdir) if file.endswith('.wav')])
    counts.append(wav_count)

# Plot a pie chart of the counts
labels = [os.path.basename(subdir) for subdir in subdirs]
plt.pie(counts, labels=labels, autopct='%1.1f%%')
plt.title('Distribution of Data')
plt.show()

"""### Visualise Dataset Before Envelop
Signal Mel Spectrogram and FFT was visualized and it was observed that there were many dead spaces.
"""

signals = {}
fft = {}
fbank = {} 
mfccs = {}

# Loop through each subdirectory and load the .wav files
for c in subdirs:
    wav_files = [f for f in os.listdir(c) if f.endswith('.wav')]
    for wav_file in wav_files:
        wav_path = os.path.join(c, wav_file)
        signal, rate = librosa.load(wav_path, sr=44100)
        signals[wav_path] = signal
        fft[wav_path] = calc_fft(signal, rate)
        bank = logfbank(signal[:rate], rate, nfilt=26, nfft=1103).T
        fbank[wav_path] = bank
        mel = mfcc(signal[:rate], rate, numcep=13, nfilt=26, nfft=1103).T
        mfccs[wav_path] = mel

# Plot the signals, FFT, filterbank energies, and MFCCs

"""#### Plot Signal"""

plot_signals(signals) 
plt.show()

"""#### Plot fft"""

plot_fft(fft)
plt.show()

"""#### plot fbank"""

plot_fbank(fbank) 
plt.show()

"""#### plot mfccs"""

plot_mfccs(mfccs) 
plt.show()

"""### Visualise Dataset After Envelop
The dead spaces were removed with a threshold of 0.0005 and the signal Mel Spectrogram and FFT were visualized again. The clean signals were into according to their respective classes.
"""

# Create the directory if it does not exist
clean_dir = os.path.join(os.getcwd(), 'clean', c.split('/')[-1])
if not os.path.exists(clean_dir):
    os.makedirs(clean_dir)

# Loop through each subdirectory and load the .wav files
for c in subdirs:
    wav_files = [f for f in os.listdir(c) if f.endswith('.wav')]
    for wav_file in wav_files:
        wav_path = os.path.join(c, wav_file)
        signal, rate = librosa.load(wav_path, sr=44100)
        if not envelope(signal, rate, 0.0005):  # Check if the signal is dead
            continue
        clean_signal = signal[np.abs(signal) > 0.0005]  # Remove values below the threshold
        # Set the path for the clean file
        clean_path = os.path.join(clean_dir, wav_file) 
        sf.write(clean_path, clean_signal, rate)
        signals[wav_path] = signal
        fft[wav_path] = calc_fft(signal, rate)
        bank = logfbank(signal[:rate], rate, nfilt=26, nfft=1103).T
        fbank[wav_path] = bank
        mel = mfcc(signal[:rate], rate, numcep=13, nfilt=26, nfft=1103).T
        mfccs[wav_path] = mel


# Plot the signals, FFT, filterbank energies, and MFCCs

"""#### Plot Signal"""

plot_signals(signals) 
plt.show()

"""#### Plot fft"""

plot_fft(fft)
plt.show()

"""#### plot fbank"""

plot_fbank(fbank) 
plt.show()

"""#### plot mfccs"""

plot_mfccs(mfccs) 
plt.show()

"""### Save Clean Signal

"""

if not os.path.exists('clean'):
    os.makedirs('clean')

# Loop through each subdirectory and load the .wav files
for c in subdirs:
    if not os.path.exists(os.path.join('clean', c.split('/')[-1])):
        os.makedirs(os.path.join('clean', c.split('/')[-1]))
    wav_files = [f for f in os.listdir(c) if f.endswith('.wav')]
    for wav_file in wav_files:
        wav_path = os.path.join(c, wav_file)
        signal, rate = librosa.load(wav_path)
        clean_signal = signal[np.abs(signal) > 0.0005]  # Remove values below the threshold
        clean_path = os.path.join('clean', c.split('/')[-1], wav_file)  # Set the path for the clean file
        try:
            sf.write(clean_path, clean_signal, rate)
        except Exception as e:
            print(f"Error writing {clean_path}: {e}")
            continue
        signals[wav_path] = signal
        fft[wav_path] = calc_fft(signal,rate)

"""# Audio classification using convolutional neural networks

Audio classification can be performed by converting audio streams into spectrograms, which provide visual representations of spectrums of frequencies as they vary over time, and classifying the spectrograms using convolutional neural networks (CNNs).

## Import Clean Sound and Mel spectrogram

The first step is to load the WAV files, use a Python package named Librosa to generate spectrogram images from them, load the spectrograms into memory, and prepare them for use in training a CNN. To aid in this process, we'll define a pair of helper functions for creating spectrograms from WAV files and converting all the WAV files in a specified directory into spectrograms.
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import librosa.display, os
import matplotlib.pyplot as plt
# %matplotlib inline

def create_spectrogram(audio_file, image_file):
    fig = plt.figure()
    ax = fig.add_subplot(1, 1, 1)
    fig.subplots_adjust(left=0, right=1, bottom=0, top=1)

    y, sr = librosa.load(audio_file)
    ms = librosa.feature.melspectrogram(y=y, sr=sr)
    log_ms = librosa.power_to_db(ms, ref=np.max)
    librosa.display.specshow(log_ms, sr=sr)

    fig.savefig(image_file)
    plt.close(fig)
    
    
def create_pngs_from_wavs(input_path, output_path):
    if not os.path.exists(output_path):
        os.makedirs(output_path)

    dir = os.listdir(input_path)

    for i, file in enumerate(dir):
        input_file = os.path.join(input_path, file)
        output_file = os.path.join(output_path, file.replace('.wav', '.png'))
        create_spectrogram(input_file, output_file)

create_pngs_from_wavs('/content/clean/class1', 'Spectrograms/class1')

create_pngs_from_wavs('/content/clean/class2', 'Spectrograms/class2')

create_pngs_from_wavs('/content/clean/class3', 'Spectrograms/class3')

create_pngs_from_wavs('/content/clean/class4', 'Spectrograms/class4')

"""##### Define two new helper functions for loading and displaying spectrograms and declare two Python lists â€” one to store spectrogram images, and another to store class labels."""

from tensorflow.keras.preprocessing import image


def load_images_from_path(path, label):
    images = []
    labels = []

    for file in os.listdir(path):
        images.append(np.array(image.load_img(os.path.join(path, file), target_size=(224, 224))))
        labels.append((label))
        
    return images, labels

def show_images(images):
    fig, axes = plt.subplots(3, 3, figsize=(20, 20), subplot_kw={'xticks': [], 'yticks': []})

    for i, ax in enumerate(axes.flat):
        ax.imshow(images[i] / 255)
        
x = []
y = []

"""#### Mel Spectrograms Of Each class"""

images, labels = load_images_from_path('/content/Spectrograms/class1', 0)
show_images(images)
    
x += images
y += labels

images, labels = load_images_from_path('/content/Spectrograms/class2', 1)
show_images(images)
    
x += images
y += labels

images, labels = load_images_from_path('/content/Spectrograms/class3', 2)
show_images(images)
    
x += images
y += labels

images, labels = load_images_from_path('/content/Spectrograms/class4', 3)
show_images(images)
    
x += images
y += labels

"""## Split into X_test and y_test

"""

from tensorflow.keras.utils import to_categorical
from sklearn.model_selection import train_test_split
import keras

from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D
from keras.layers import Flatten, Dense

x_train, x_test, y_train, y_test = train_test_split(x, y, stratify=y, test_size=0.3, random_state=0)

x_train_norm = np.array(x_train) / 255
x_test_norm = np.array(x_test) / 255

y_train_encoded = to_categorical(y_train)
y_test_encoded = to_categorical(y_test)

"""## CNN
convolutional neural networks that use convolution layers to extract features from images and pooling layers to downsize images so features can be detected at various resolutions. The next task is to build a CNN containing a series of convolution and pooling layers for feature extraction, a pair of fully connected layers for classification, and a softmax layer that outputs probabilities for each class, and to train it with spectrogram images and labels. Start by defining the CNN
"""

np.unique(y_train)

# encode target values as one-hot vectors
num_classes = 4
y_train_encoded = keras.utils.to_categorical(y_train, num_classes)
y_test_encoded = keras.utils.to_categorical(y_test, num_classes)

model = Sequential()
model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(224, 224, 3)))
model.add(MaxPooling2D(2, 2))
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D(2, 2))
model.add(Conv2D(128, (3, 3), activation='relu'))
model.add(MaxPooling2D(2, 2))
model.add(Conv2D(256, (3, 3), activation='relu'))
model.add(MaxPooling2D(2, 2))
model.add(Flatten())
model.add(Dense(1024, activation='relu'))
model.add(Dense(num_classes, activation='softmax'))

# Change loss function to SparseCategoricalCrossentropy and activation function of the output layer to 'sigmoid'
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
# train the model
batch_size = 16
epochs = 20
hist = model.fit(x_train_norm, y_train_encoded, validation_data=(x_test_norm, y_test_encoded), batch_size=batch_size, epochs=epochs)

acc = hist.history['accuracy']
val_acc = hist.history['val_accuracy']
epochs = range(1, len(acc) + 1)

plt.plot(epochs, acc, '-', label='Training Accuracy')
plt.plot(epochs, val_acc, ':', label='Validation Accuracy')
plt.title('Training and Validation Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend(loc='lower right')
plt.plot()

"""### Confusion matrix"""

from sklearn.metrics import confusion_matrix
import seaborn as sns
sns.set()

# Generate predictions and calculate confusion matrix
y_predicted = model.predict(x_test_norm)
mat = confusion_matrix(y_test_encoded.argmax(axis=1), y_predicted.argmax(axis=1))
class_names = ['class1', 'class2', 'class3', 'class4']

# Normalize the confusion matrix
normalized_mat = mat.astype('float') / mat.sum(axis=1)[:, np.newaxis]

# Create the heatmap
fig, ax = plt.subplots()
sns.heatmap(normalized_mat, annot=True, cmap='Blues', cbar=False, 
            xticklabels=class_names, yticklabels=class_names,
            square=True, fmt='.2f', annot_kws={"fontsize":16})

# Set the tick labels and tick locations
ax.set_xticklabels(class_names, fontsize=16)
ax.set_yticklabels(class_names, fontsize=16, rotation=0)
plt.xticks(rotation=90)
plt.xlabel('Predicted label', fontsize=16)
plt.ylabel('True label', fontsize=16)
plt.title('Normalized Confusion Matrix', fontsize=20)

plt.show()

"""## Use transfer learning to improve accuracy

Transfer learning is a powerful technique that allows sophisticated CNNs trained by Google, Microsoft, and others on GPUs to be repurposed and used to solve domain-specific problems. Many pretrained CNNs are available in the public domain, and several are included with Keras. Let's use MobileNetV2, a pretrained CNN from Google that is optimized for mobile devices, to extract features from spectrogram images.

> MobileNetV2 requires less processing power and has a smaller memory footprint than CNNs such as ResNet50V2. That's why it is ideal for mobile devices. You can learn more about it in the Google AI blog.

Start by calling Keras's MobileNetV2 function to instantiate MobileNetV2 without the classification layers. Use the preprocess_input function for MobileNet networks to preprocess the training and testing images. Then run both datasets through MobileNetV2 to extract features.

Transfer learning is a powerful technique that allows sophisticated CNNs trained by Google, Microsoft, and others on GPUs to be repurposed and used to solve domain-specific problems. Many pretrained CNNs are available in the public domain, and several are included with Keras. Let's use MobileNetV2, a pretrained CNN from Google that is optimized for mobile devices, to extract features from spectrogram images.
"""

from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.applications.mobilenet import preprocess_input

base_model = MobileNetV2(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

x_train_norm = preprocess_input(np.array(x_train))
x_test_norm = preprocess_input(np.array(x_test))

train_features = base_model.predict(x_train_norm)
test_features = base_model.predict(x_test_norm)

model = Sequential()
model.add(Flatten(input_shape=train_features.shape[1:]))
model.add(Dense(1024, activation='relu'))
model.add(Dense(4, activation='softmax'))
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

hist = model.fit(train_features, y_train_encoded, validation_data=(test_features, y_test_encoded), batch_size=3, epochs=2)

acc = hist.history['accuracy']
val_acc = hist.history['val_accuracy']
epochs = range(1, len(acc) + 1)

plt.plot(epochs, acc, '-', label='Training Accuracy')
plt.plot(epochs, val_acc, ':', label='Validation Accuracy')
plt.title('Training and Validation Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend(loc='lower right')
plt.plot()

"""### Run the test images through the network and use a confusion matrix to assess the results."""

from sklearn.metrics import confusion_matrix
import seaborn as sns
sns.set()

# Generate predictions and calculate confusion matrix
y_predicted = model.predict(test_features)
mat = confusion_matrix(y_test_encoded.argmax(axis=1), y_predicted.argmax(axis=1))
class_names = ['class1', 'class2', 'class3', 'class4']

# Normalize the confusion matrix
normalized_mat = mat.astype('float') / mat.sum(axis=1)[:, np.newaxis]

# Create the heatmap
fig, ax = plt.subplots()
sns.heatmap(normalized_mat, annot=True, cmap='Blues', cbar=False, 
            xticklabels=class_names, yticklabels=class_names,
            square=True, fmt='.2f', annot_kws={"fontsize":16})

# Set the tick labels and tick locations
ax.set_xticklabels(class_names, fontsize=16)
ax.set_yticklabels(class_names, fontsize=16, rotation=0)
plt.xticks(rotation=90)
plt.xlabel('Predicted label', fontsize=16)
plt.ylabel('True label', fontsize=16)
plt.title('Normalized Confusion Matrix', fontsize=20)

plt.show()